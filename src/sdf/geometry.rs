use std::{ops::RangeInclusive, sync::Arc};
use slotmap::{new_key_type, SlotMap};
use crate::framework::{math::Transform, gpu};

use super::{svo::Svo, primitives::Primitive};

new_key_type! {
    /// An index of geometry instance which can be shared between multiple models
    pub struct GeometryID;
}

pub type GeometryPool = SlotMap<GeometryID, Geometry>;

#[derive(Clone, PartialEq, Debug)]
pub enum GeometryOperation {
    Add       = 0,
    Subtract  = 1,
    Intersect = 2,
    // TODO: Paint
}

#[derive(Clone, Debug)]
pub struct GeometryEdit {
    pub primitive: Primitive,
    pub operation: GeometryOperation,
    pub transform: Transform,
    pub blending:  f32,
}

pub enum GeometryEvaluationStatus {
    NeedsEvaluation,
    Evaluating,
    Evaluated,
}

pub struct GPUResources {
    /// A list of edits properly formatted and residing in GPU memory
    pub edits: GeometryEditsGPU,
    
    /// A Sparse Voxel Octree evaluated into GPU memory
    pub svo: Svo,
}

pub struct Geometry {
    
    /// A list of edits that compose this geometry on CPU
    pub edits: Vec<GeometryEdit>,
    
    /// A data generated by evaluator which residing in GPU memory
    pub gpu_resources: Option<GPUResources>,
    
    /// The status of the geometry evaluation used by evaluator
    ///   - `NeedsEvaluation` means that the geometry has been edited and needs to be evaluated
    ///      evaluator on next update collects all geometries with this status and spawns and evaluation job.
    ///   - `Evaluating` means that the geometry is currently being evaluated by evaluator.
    ///   - `Evaluated` means that the geometry does not need to be evaluated.
    pub evaluation_status: GeometryEvaluationStatus,
    
    /// nodes containing voxels bigger that this will be subdivided
    min_voxel_size: f32,
}

impl Geometry {
    pub const VOXEL_SIZE_RANGE: RangeInclusive<f32> = 0.005..=0.1;
    
    pub fn new(min_voxel_size: f32) -> Self {
        Self {
            edits:             vec![],
            gpu_resources:     None,
            evaluation_status: GeometryEvaluationStatus::NeedsEvaluation,
            min_voxel_size: min_voxel_size.clamp(*Self::VOXEL_SIZE_RANGE.start(), *Self::VOXEL_SIZE_RANGE.end()),
        }
    }
    
    pub fn with_edits(mut self, edits: Vec<GeometryEdit>) -> Self {
        self.edits = edits;
        self
    }
    
    pub fn min_voxel_size(&self) -> f32 {
        self.min_voxel_size
    }
    
    pub fn set_min_voxel_size(&mut self, min_voxel_size: f32) {
        self.min_voxel_size = min_voxel_size.clamp(*Self::VOXEL_SIZE_RANGE.start(), *Self::VOXEL_SIZE_RANGE.end());
        self.evaluation_status = GeometryEvaluationStatus::NeedsEvaluation;
    }
    
}

/// =================================================================================================
/// Edit list on GPU
/// =================================================================================================

#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
pub struct GeometryGPUEdit {
    pub operation: u32,
    pub primitive: u32,
}

#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
pub struct GeometryGPUEditData {
    blending_level:  f32,
    additional_data: glam::Vec3,
}

pub struct GeometryEditsGPU {
    pub edits:      gpu::Buffer<GeometryGPUEdit>,
    pub editData:   gpu::Buffer<GeometryGPUEditData>,
    pub transforms: gpu::Buffer<glam::Mat4>,
}

impl GeometryEditsGPU {
    #[profiler::function]
    pub fn from_edit_list(gpu: &gpu::Context, edits: &[GeometryEdit]) -> Self {
        let (
            edits_gpu,
            edit_data,
            transforms
        ) = Self::map_data(edits);
        
        Self {
            edits:      gpu::Buffer::new(gpu, Some("Geometry edits"), &edits_gpu, wgpu::BufferUsages::STORAGE),
            editData:   gpu::Buffer::new(gpu, Some("Geometry edit Data"), &edit_data, wgpu::BufferUsages::STORAGE),
            transforms: gpu::Buffer::new(gpu, Some("Geometry edit transforms"), &transforms, wgpu::BufferUsages::STORAGE),
        }
    }
    
    pub fn queue_update(&mut self, gpu: &gpu::Context, edits: &[GeometryEdit]) {
        let (
            edits_gpu,
            edit_data,
            transforms
        ) = Self::map_data(edits);
        
        self.edits.queue_update(gpu, &edits_gpu);
        self.editData.queue_update(gpu, &edit_data);
        self.transforms.queue_update(gpu, &transforms);
    }
    
    #[profiler::function]
    fn map_data(edits: &[GeometryEdit]) -> (Vec<GeometryGPUEdit>, Vec<GeometryGPUEditData>, Vec<glam::Mat4>) {
        let mut edits_gpu = vec![];
        let mut edit_data = vec![];
        let mut transforms = vec![];
        
        for edit in edits {
            let edit_gpu = GeometryGPUEdit {
                operation: edit.operation.clone() as u32,
                primitive: edit.primitive.get_id(),
            };
            let edit_data_gpu = GeometryGPUEditData {
                blending_level: edit.blending,
                additional_data: glam::Vec3::ZERO,
            };
            let transform_gpu = edit.transform.as_mat();
            
            edits_gpu.push(edit_gpu);
            edit_data.push(edit_data_gpu);
            transforms.push(transform_gpu);
        }
        
        (edits_gpu, edit_data, transforms)
    }
    
    #[profiler::function]
    pub fn create_bind_group_layout(gpu: &gpu::Context, visibility: wgpu::ShaderStages) -> wgpu::BindGroupLayout {
        gpu.device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Geometry edits bind group layout"),
            entries: &[
                // Buffer with edits
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                // Buffer with edits data
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
                // Buffer with transforms
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Storage { read_only: true },
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        })
    }
    
    #[profiler::function]
    pub fn create_bind_group(&self, gpu: &gpu::Context, layout: &wgpu::BindGroupLayout) -> wgpu::BindGroup {
        gpu.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Geometry edits bind group"),
            layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: self.edits.buffer.as_entire_binding(),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: self.editData.buffer.as_entire_binding(),
                },
                wgpu::BindGroupEntry {
                    binding: 2,
                    resource: self.transforms.buffer.as_entire_binding(),
                },
            ],
        })
    }
}
