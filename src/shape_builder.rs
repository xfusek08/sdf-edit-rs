
use std::{io::{Write, Read}, path::Path};

use crate::{
    framework::math::Transform, sdf::geometry::{Primitive, Operation, Edit},
};

#[derive(Debug)]
pub enum Shape {
    Primitive(Primitive),
    Composite(Vec<ShapeRecord>),
    PrimitiveComposite((Primitive, Vec<ShapeRecord>)),
}

#[derive(Debug)]
pub struct ShapeRecord {
    pub shape:     Shape,
    pub operation: Operation,
    pub transform: Transform,
    pub blending:  f32,
}

// API - Factories shortcuts
impl Shape {
    pub fn empty() -> Self                                               { Shape::Composite(vec![]) }
    pub fn sphere(radius: f32) -> Self                                   { Shape::Primitive(Primitive::Sphere { radius }) }
    pub fn cube(width: f32, height: f32, depth: f32, bevel: f32) -> Self { Shape::Primitive(Primitive::Cube { width, height, depth, bevel }) }
    pub fn cylinder(diameter: f32, height: f32) -> Self                  { Shape::Primitive(Primitive::Cylinder { diameter, height }) }
    pub fn torus(inner_radius: f32, outer_radius: f32) -> Self           { Shape::Primitive(Primitive::Torus { inner_radius, outer_radius }) }
    pub fn cone(diameter: f32, height: f32) -> Self                      { Shape::Primitive(Primitive::Cone { diameter, height }) }
    pub fn capsule(radius: f32, height: f32) -> Self                     { Shape::Primitive(Primitive::Capsule { radius, height }) }
}

// API - Default
impl Default for Shape {
    fn default() -> Self {
        Self::empty()
    }
}

// API - Construction Geometry
impl Shape {
    pub fn add(self, shape: Shape, transform: Transform, blending: f32) -> Self {
        self.add_child_operation(Operation::Add, shape, transform, blending)
    }
    
    pub fn subtract(self, shape: Shape, transform: Transform, blending: f32) -> Self {
        self.add_child_operation(Operation::Subtract, shape, transform, blending)
    }
}

// API - Exporting Geometry List
impl Shape {
    /// Returns flat list of geometry edits for sdf module to evaluate
    /// The list is generated by in-order traversal of the Shape structure and applying transforms and operations along the way
    pub fn build(&self) -> Vec<Edit> {
        let mut result: Vec<Edit> = vec![];
        Self::generate_flat_edits_recursive(
            self,
            &mut result,
            Transform::IDENTITY,
            Operation::Add,
            0.0
        );
        result
    }
    
    pub fn composite_from_edits(edits: Vec<Edit>) -> Self {
        Shape::Composite(edits.into_iter().map(|edit| ShapeRecord {
            shape:     Shape::Primitive(edit.primitive),
            operation: edit.operation,
            transform: edit.transform,
            blending:  edit.blending
        }).collect())
    }
    
    pub fn store_flat_edits<P>(&self, file_name: P) -> Result<(), String>
    where
        P: AsRef<Path>
    {
        
        // Serialize edits
        let edits = self.build();
        let str = match serde_json::to_string(&edits) {
            Ok(str) => str,
            Err(err) => return Err(format!("Failed to serialize edits: {}", err))
        };
        
        // Create file
        let mut file = match std::fs::File::create(file_name) {
            Ok(file) => file,
            Err(err) => return Err(format!("Failed to create file: {}", err))
        };
        
        // Write to file
        match file.write(str.as_bytes()) {
            Ok(_) => Ok(()),
            Err(err) => Err(format!("Failed to write to file: {}", err))
        }
    }
    
    pub fn load_store_edits<P>(file_name: P) -> Result<Self, String>
    where
        P: AsRef<Path>
    {
        // Open file
        let mut file = match std::fs::File::open(file_name) {
            Ok(file) => file,
            Err(err) => return Err(format!("Failed to open file: {}", err))
        };
        
        // Read file
        let mut str = String::new();
        match file.read_to_string(&mut str) {
            Ok(_) => {},
            Err(err) => return Err(format!("Failed to read file: {}", err))
        }
        
        Self::from_string(&str)
    }
    
    pub fn from_string(str: &str) -> Result<Self, String>
    {
        // Deserialize edits
        let edits: Vec<Edit> = match serde_json::from_str(&str) {
            Ok(edits) => edits,
            Err(err) => return Err(format!("Failed to deserialize edits: {}", err))
        };
        
        // Build composite
        Ok(Shape::composite_from_edits(edits))
    }
}

// Private
impl Shape {
    #[inline]
    fn add_child_operation(mut self, operation: Operation, shape: Shape, transform: Transform, blending: f32) -> Self {
        match self {
            Shape::Composite(ref mut children) => {
                children.push(ShapeRecord { shape, operation, transform, blending });
                self
            },
            Shape::Primitive(primitive) => {
                Shape::PrimitiveComposite((primitive, vec![ShapeRecord { shape, operation, transform, blending }]))
            },
            Shape::PrimitiveComposite((_, ref mut children)) => {
                children.push(ShapeRecord { shape, operation, transform, blending });
                self
            },
        }
    }
    
    fn add_primitive_to_list(primitive: &Primitive, target_list: &mut Vec<Edit>, transform: Transform, operation: Operation, blending: f32) {
        target_list.push(Edit { primitive: primitive.clone(), operation, transform, blending });
    }
    
    fn add_children_to_list(children: &Vec<ShapeRecord>, target_list: &mut Vec<Edit>, transform: Transform, operation: Operation, blending: f32) {
        for child in children {
            Self::generate_flat_edits_recursive(
                &child.shape,
                target_list,
                child.transform.add(&transform),
                if operation == Operation::Add { child.operation.clone() } else { operation.clone() },
                if operation == Operation::Add { child.blending } else { blending }
            );
        }
    }
    
    fn generate_flat_edits_recursive(shape: &Shape, target_list: &mut Vec<Edit>, transform: Transform, operation: Operation, blending: f32) {
        match shape {
            Shape::Primitive(primitive) => {
                Self::add_primitive_to_list(primitive, target_list, transform, operation, blending);
            },
            Shape::Composite(children) => {
                Self::add_children_to_list(children, target_list, transform, operation, blending);
            },
            Shape::PrimitiveComposite((primitive, children)) => {
                Self::add_primitive_to_list(primitive, target_list, transform.clone(), operation.clone(), blending);
                Self::add_children_to_list(children, target_list, transform.clone(), operation.clone(), blending);
            },
        }
    }
    
}
