
use crate::{
    framework::math::Transform,
    sdf::{
        primitives::Primitive,
        geometry::{GeometryOperation, GeometryEdit},
    }
};

#[derive(Debug)]
pub enum Shape {
    Primitive(Primitive),
    Composite(Vec<ShapeRecord>),
    PrimitiveComposite((Primitive, Vec<ShapeRecord>)),
}

#[derive(Debug)]
pub struct ShapeRecord {
    shape:     Shape,
    operation: GeometryOperation,
    transform: Transform,
    blending:  f32,
}

// factories
impl Shape {
    pub fn empty() -> Self                                                   { Shape::Composite(vec![]) }
    pub fn sphere() -> Self                                                  { Shape::Primitive(Primitive::Sphere) }
    pub fn cube() -> Self                                                    { Shape::Primitive(Primitive::Cube) }
    pub fn cylinder() -> Self                                                { Shape::Primitive(Primitive::Cylinder) }
    pub fn torus(inner_radius: f32, outer_radius: f32) -> Self               { Shape::Primitive(Primitive::Torus { inner_radius, outer_radius }) }
    pub fn cone(base_radius: f32) -> Self                                    { Shape::Primitive(Primitive::Cone { base_radius }) }
    pub fn capsule(top_radius: f32, bottom_radius: f32, height: f32) -> Self { Shape::Primitive(Primitive::Capsule { top_radius, bottom_radius, height }) }
}

// API - Construction Geometry
impl Shape {
    pub fn add(self, shape: Shape, transform: Transform, blending: f32) -> Self {
        self.add_child_operation(GeometryOperation::Add, shape, transform, blending)
    }
    
    pub fn subtract(self, shape: Shape, transform: Transform, blending: f32) -> Self {
        self.add_child_operation(GeometryOperation::Subtract, shape, transform, blending)
    }
}

// API - Exporting Geometry List
impl Shape {
    /// Returns flat list of geometry edits for sdf module to evaluate
    /// The list is generated by in-order traversal of the Shape structure and applying transforms and operations along the way
    pub fn build(&self) -> Vec<GeometryEdit> {
        let mut result: Vec<GeometryEdit> = vec![];
        Self::generate_flat_edits_recursive(
            self,
            &mut result,
            Transform::IDENTITY,
            GeometryOperation::Add,
            0.0
        );
        result
    }
}

// private
impl Shape {
    #[inline]
    fn add_child_operation(mut self, operation: GeometryOperation, shape: Shape, transform: Transform, blending: f32) -> Self {
        match self {
            Shape::Composite(ref mut children) => {
                children.push(ShapeRecord { shape, operation, transform, blending });
                self
            },
            Shape::Primitive(primitive) => {
                Shape::PrimitiveComposite((primitive, vec![ShapeRecord { shape, operation, transform, blending }]))
            },
            Shape::PrimitiveComposite((_, ref mut children)) => {
                children.push(ShapeRecord { shape, operation, transform, blending });
                self
            },
        }
    }
    
    fn generate_flat_edits_recursive(shape: &Shape, target_list: &mut Vec<GeometryEdit>, transform: Transform, operation: GeometryOperation, blending: f32) {
        match shape {
            Shape::Primitive(primitive) => {
                Self::add_primitive_to_list(primitive, target_list, transform, operation, blending);
            },
            Shape::Composite(children) => {
                Self::add_children_to_list(children, target_list, transform, operation, blending);
            },
            Shape::PrimitiveComposite((primitive, children)) => {
                Self::add_primitive_to_list(primitive, target_list, transform.clone(), operation.clone(), blending);
                Self::add_children_to_list(children, target_list, transform.clone(), operation.clone(), blending);
            },
        }
    }
    
    fn add_primitive_to_list(primitive: &Primitive, target_list: &mut Vec<GeometryEdit>, transform: Transform, operation: GeometryOperation, blending: f32) {
        target_list.push(GeometryEdit { primitive: primitive.clone(), operation, transform, blending });
    }
    
    fn add_children_to_list(children: &Vec<ShapeRecord>, target_list: &mut Vec<GeometryEdit>, transform: Transform, operation: GeometryOperation, blending: f32) {
        for child in children {
            Self::generate_flat_edits_recursive(
                &child.shape,
                target_list,
                child.transform.add(&transform),
                if operation == GeometryOperation::Add { child.operation.clone() } else { operation.clone() },
                if operation == GeometryOperation::Add { child.blending } else { blending }
            );
        }
    }
}
