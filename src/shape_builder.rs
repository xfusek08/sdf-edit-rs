
use crate::{
    framework::math::Transform, sdf::geometry::{Primitive, Operation, Edit},
};

#[derive(Debug)]
pub enum Shape {
    Primitive(Primitive),
    Composite(Vec<ShapeRecord>),
    PrimitiveComposite((Primitive, Vec<ShapeRecord>)),
}

#[derive(Debug)]
pub struct ShapeRecord {
    pub shape:     Shape,
    pub operation: Operation,
    pub transform: Transform,
    pub blending:  f32,
}

// API - Factories shortcuts
impl Shape {
    pub fn empty() -> Self                                                   { Shape::Composite(vec![]) }
    pub fn sphere(radius: f32) -> Self                                       { Shape::Primitive(Primitive::Sphere { radius }) }
    pub fn cube(width: f32, height: f32, depth: f32) -> Self                 { Shape::Primitive(Primitive::Cube { width, height, depth }) }
    pub fn cylinder(diameter: f32, height: f32) -> Self                      { Shape::Primitive(Primitive::Cylinder { diameter, height }) }
    pub fn torus(inner_radius: f32, outer_radius: f32) -> Self               { Shape::Primitive(Primitive::Torus { inner_radius, outer_radius }) }
    pub fn cone(diameter: f32, height: f32) -> Self                          { Shape::Primitive(Primitive::Cone { diameter, height }) }
    pub fn capsule(radius: f32, height: f32) -> Self                         { Shape::Primitive(Primitive::Capsule { radius, height }) }
}

// API - Default
impl Default for Shape {
    fn default() -> Self {
        Self::empty()
    }
}

// API - Construction Geometry
impl Shape {
    pub fn add(self, shape: Shape, transform: Transform, blending: f32) -> Self {
        self.add_child_operation(Operation::Add, shape, transform, blending)
    }
    
    pub fn subtract(self, shape: Shape, transform: Transform, blending: f32) -> Self {
        self.add_child_operation(Operation::Subtract, shape, transform, blending)
    }
}

// API - Exporting Geometry List
impl Shape {
    /// Returns flat list of geometry edits for sdf module to evaluate
    /// The list is generated by in-order traversal of the Shape structure and applying transforms and operations along the way
    pub fn build(&self) -> Vec<Edit> {
        let mut result: Vec<Edit> = vec![];
        Self::generate_flat_edits_recursive(
            self,
            &mut result,
            Transform::IDENTITY,
            Operation::Add,
            0.0
        );
        result
    }
}

// Private
impl Shape {
    #[inline]
    fn add_child_operation(mut self, operation: Operation, shape: Shape, transform: Transform, blending: f32) -> Self {
        match self {
            Shape::Composite(ref mut children) => {
                children.push(ShapeRecord { shape, operation, transform, blending });
                self
            },
            Shape::Primitive(primitive) => {
                Shape::PrimitiveComposite((primitive, vec![ShapeRecord { shape, operation, transform, blending }]))
            },
            Shape::PrimitiveComposite((_, ref mut children)) => {
                children.push(ShapeRecord { shape, operation, transform, blending });
                self
            },
        }
    }
    
    fn add_primitive_to_list(primitive: &Primitive, target_list: &mut Vec<Edit>, transform: Transform, operation: Operation, blending: f32) {
        target_list.push(Edit { primitive: primitive.clone(), operation, transform, blending });
    }
    
    fn add_children_to_list(children: &Vec<ShapeRecord>, target_list: &mut Vec<Edit>, transform: Transform, operation: Operation, blending: f32) {
        for child in children {
            Self::generate_flat_edits_recursive(
                &child.shape,
                target_list,
                child.transform.add(&transform),
                if operation == Operation::Add { child.operation.clone() } else { operation.clone() },
                if operation == Operation::Add { child.blending } else { blending }
            );
        }
    }
    
    fn generate_flat_edits_recursive(shape: &Shape, target_list: &mut Vec<Edit>, transform: Transform, operation: Operation, blending: f32) {
        match shape {
            Shape::Primitive(primitive) => {
                Self::add_primitive_to_list(primitive, target_list, transform, operation, blending);
            },
            Shape::Composite(children) => {
                Self::add_children_to_list(children, target_list, transform, operation, blending);
            },
            Shape::PrimitiveComposite((primitive, children)) => {
                Self::add_primitive_to_list(primitive, target_list, transform.clone(), operation.clone(), blending);
                Self::add_children_to_list(children, target_list, transform.clone(), operation.clone(), blending);
            },
        }
    }
    
}
